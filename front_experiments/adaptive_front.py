"""Analytic functions for in the case of the bi-exponential weight kernel.
Note: Originally the synaptic efficacy term in the model had a factor of
`alpha*beta`, but this was later changed to simply beta.
"""
import numpy as np

def response(pulse_amp, *, mu, alpha, beta, theta, **_):
    c = get_speed(mu=mu, alpha=alpha, beta=beta, theta=theta)
    denominator = theta*c*mu**2/(1+c*mu) - mu*alpha*beta*c/2/(1+beta+c*alpha)**2/(1+c*mu)
    numerator = pulse_amp*c*mu
    return numerator/denominator

def response_q(pulse_amp, *, mu, alpha, beta, theta, **_):
    c = get_speed(mu=mu, alpha=alpha, beta=beta, theta=theta)
    denominator = theta*c*mu**2/(1+c*mu) - mu*alpha*beta*c/2/(1+beta+c*alpha)**2/(1+c*mu)
    numerator = (1+c*alpha)*c*mu/2/(1+c*mu)/(1+beta+alpha*c)
    return numerator/denominator

# code below generated in symbolic.ipynb

def get_speed(*, mu, alpha, theta, beta, **_):
    return (1.0/4.0)*(-2*alpha*theta + alpha - 2*beta*mu*theta - 2*mu*theta + np.sqrt(4*( lambda base, exponent: base**exponent )(alpha, 2)*( lambda base, exponent: base**exponent )(theta, 2) - 4*( lambda base, exponent: base**exponent )(alpha, 2)*theta + ( lambda base, exponent: base**exponent )(alpha, 2) - 8*alpha*beta*mu*( lambda base, exponent: base**exponent )(theta, 2) - 4*alpha*beta*mu*theta - 8*alpha*mu*( lambda base, exponent: base**exponent )(theta, 2) + 4*alpha*mu*theta + 4*( lambda base, exponent: base**exponent )(beta, 2)*( lambda base, exponent: base**exponent )(mu, 2)*( lambda base, exponent: base**exponent )(theta, 2) + 8*beta*( lambda base, exponent: base**exponent )(mu, 2)*( lambda base, exponent: base**exponent )(theta, 2) + 4*( lambda base, exponent: base**exponent )(mu, 2)*( lambda base, exponent: base**exponent )(theta, 2)))/(alpha*mu*theta)

def Q_numeric(xi, mu, alpha, beta, theta, **_):
    c = get_speed(mu=mu, alpha=alpha, beta=beta, theta=theta)
    return (lambda input: np.heaviside(input,0.5))(xi) + (beta*np.exp(xi*(beta + 1)/(alpha*c)) + 1)*(lambda input: np.heaviside(input,0.5))(-xi)/(beta + 1)

def U_numeric(xi, mu, alpha, beta, theta, **_):
    c = get_speed(mu=mu, alpha=alpha, beta=beta, theta=theta)
    return (1.0/2.0)*(alpha*c + 1)*np.exp(-xi)*(lambda input: np.heaviside(input,0.5))(xi)/((mu*c + 1)*(alpha*c + beta + 1)) + ((1.0/2.0)*( lambda base, exponent: base**exponent )(alpha, 2)*beta*c*np.exp(xi*(beta + 1)/(alpha*c))/((alpha - beta*mu - mu)*(alpha*beta*c + alpha*c + ( lambda base, exponent: base**exponent )(beta, 2) + 2*beta + 1)) + (1.0/2.0)*( lambda base, exponent: base**exponent )(alpha, 2)*beta*c*np.exp(xi*(beta + 1)/(alpha*c))/((alpha - beta*mu - mu)*(alpha*beta*c + alpha*c - ( lambda base, exponent: base**exponent )(beta, 2) - 2*beta - 1)) + (1.0/2.0)*alpha*c/(alpha*beta*c + alpha*c + ( lambda base, exponent: base**exponent )(beta, 2) + 2*beta + 1) + (1.0/2.0)*beta/(alpha*beta*c + alpha*c + ( lambda base, exponent: base**exponent )(beta, 2) + 2*beta + 1) + (-( lambda base, exponent: base**exponent )(alpha, 2)*beta*mu*( lambda base, exponent: base**exponent )(c, 2)/(alpha*beta*c + alpha*c + ( lambda base, exponent: base**exponent )(beta, 2) + 2*beta + 1) - ( lambda base, exponent: base**exponent )(alpha, 2)*beta*mu*( lambda base, exponent: base**exponent )(c, 2)/(alpha*beta*c + alpha*c - ( lambda base, exponent: base**exponent )(beta, 2) - 2*beta - 1) + ( lambda base, exponent: base**exponent )(alpha, 2)*beta*c/(alpha*beta*c + alpha*c + ( lambda base, exponent: base**exponent )(beta, 2) + 2*beta + 1) + ( lambda base, exponent: base**exponent )(alpha, 2)*beta*c/(alpha*beta*c + alpha*c - ( lambda base, exponent: base**exponent )(beta, 2) - 2*beta - 1) + 2*alpha*mu*theta*c - alpha*mu*c*(alpha*c/(alpha*beta*c + alpha*c + ( lambda base, exponent: base**exponent )(beta, 2) + 2*beta + 1) + beta/(alpha*beta*c + alpha*c + ( lambda base, exponent: base**exponent )(beta, 2) + 2*beta + 1) + 1.0/(alpha*beta*c + alpha*c + ( lambda base, exponent: base**exponent )(beta, 2) + 2*beta + 1)) - alpha*mu*c/(beta + 1) - 2*alpha*theta + alpha*(alpha*c/(alpha*beta*c + alpha*c + ( lambda base, exponent: base**exponent )(beta, 2) + 2*beta + 1) + beta/(alpha*beta*c + alpha*c + ( lambda base, exponent: base**exponent )(beta, 2) + 2*beta + 1) + 1.0/(alpha*beta*c + alpha*c + ( lambda base, exponent: base**exponent )(beta, 2) + 2*beta + 1)) + alpha*(-alpha*beta*c/(alpha*beta*c + alpha*c - ( lambda base, exponent: base**exponent )(beta, 2) - 2*beta - 1) - alpha*c/(alpha*beta*c + alpha*c - ( lambda base, exponent: base**exponent )(beta, 2) - 2*beta - 1) + beta/(alpha*beta*c + alpha*c - ( lambda base, exponent: base**exponent )(beta, 2) - 2*beta - 1) + 1.0/(alpha*beta*c + alpha*c - ( lambda base, exponent: base**exponent )(beta, 2) - 2*beta - 1)) + alpha/(beta + 1) - 2*beta*( lambda base, exponent: base**exponent )(mu, 2)*theta*c + beta*( lambda base, exponent: base**exponent )(mu, 2)*c*(alpha*c/(alpha*beta*c + alpha*c + ( lambda base, exponent: base**exponent )(beta, 2) + 2*beta + 1) + beta/(alpha*beta*c + alpha*c + ( lambda base, exponent: base**exponent )(beta, 2) + 2*beta + 1) + 1.0/(alpha*beta*c + alpha*c + ( lambda base, exponent: base**exponent )(beta, 2) + 2*beta + 1)) + beta*( lambda base, exponent: base**exponent )(mu, 2)*c/(beta + 1) + 2*beta*mu*theta - beta*mu*(alpha*c/(alpha*beta*c + alpha*c + ( lambda base, exponent: base**exponent )(beta, 2) + 2*beta + 1) + beta/(alpha*beta*c + alpha*c + ( lambda base, exponent: base**exponent )(beta, 2) + 2*beta + 1) + 1.0/(alpha*beta*c + alpha*c + ( lambda base, exponent: base**exponent )(beta, 2) + 2*beta + 1)) - beta*mu*(-alpha*beta*c/(alpha*beta*c + alpha*c - ( lambda base, exponent: base**exponent )(beta, 2) - 2*beta - 1) - alpha*c/(alpha*beta*c + alpha*c - ( lambda base, exponent: base**exponent )(beta, 2) - 2*beta - 1) + beta/(alpha*beta*c + alpha*c - ( lambda base, exponent: base**exponent )(beta, 2) - 2*beta - 1) + 1.0/(alpha*beta*c + alpha*c - ( lambda base, exponent: base**exponent )(beta, 2) - 2*beta - 1)) - beta*mu/(beta + 1) - 2*( lambda base, exponent: base**exponent )(mu, 2)*theta*c + ( lambda base, exponent: base**exponent )(mu, 2)*c*(alpha*c/(alpha*beta*c + alpha*c + ( lambda base, exponent: base**exponent )(beta, 2) + 2*beta + 1) + beta/(alpha*beta*c + alpha*c + ( lambda base, exponent: base**exponent )(beta, 2) + 2*beta + 1) + 1.0/(alpha*beta*c + alpha*c + ( lambda base, exponent: base**exponent )(beta, 2) + 2*beta + 1)) + ( lambda base, exponent: base**exponent )(mu, 2)*c/(beta + 1) + 2*mu*theta - mu*(alpha*c/(alpha*beta*c + alpha*c + ( lambda base, exponent: base**exponent )(beta, 2) + 2*beta + 1) + beta/(alpha*beta*c + alpha*c + ( lambda base, exponent: base**exponent )(beta, 2) + 2*beta + 1) + 1.0/(alpha*beta*c + alpha*c + ( lambda base, exponent: base**exponent )(beta, 2) + 2*beta + 1)) - mu*(-alpha*beta*c/(alpha*beta*c + alpha*c - ( lambda base, exponent: base**exponent )(beta, 2) - 2*beta - 1) - alpha*c/(alpha*beta*c + alpha*c - ( lambda base, exponent: base**exponent )(beta, 2) - 2*beta - 1) + beta/(alpha*beta*c + alpha*c - ( lambda base, exponent: base**exponent )(beta, 2) - 2*beta - 1) + 1.0/(alpha*beta*c + alpha*c - ( lambda base, exponent: base**exponent )(beta, 2) - 2*beta - 1)) - mu/(beta + 1))*np.exp(xi/(mu*c))/(2*alpha*mu*c - 2*alpha - 2*beta*( lambda base, exponent: base**exponent )(mu, 2)*c + 2*beta*mu - 2*( lambda base, exponent: base**exponent )(mu, 2)*c + 2*mu) + (1.0/2.0)/(alpha*beta*c + alpha*c + ( lambda base, exponent: base**exponent )(beta, 2) + 2*beta + 1) - 1.0/2.0*(-alpha*beta*c/(alpha*beta*c + alpha*c - ( lambda base, exponent: base**exponent )(beta, 2) - 2*beta - 1) - alpha*c/(alpha*beta*c + alpha*c - ( lambda base, exponent: base**exponent )(beta, 2) - 2*beta - 1) + beta/(alpha*beta*c + alpha*c - ( lambda base, exponent: base**exponent )(beta, 2) - 2*beta - 1) + 1.0/(alpha*beta*c + alpha*c - ( lambda base, exponent: base**exponent )(beta, 2) - 2*beta - 1))*np.exp(xi)/(mu*c - 1) + (1.0/2.0)/(beta + 1))*(lambda input: np.heaviside(input,0.5))(-xi) 


def v1(*, xs, mu, c, **_):
    return np.heaviside(xs, 0)*np.exp(-xs/(c*mu))


def v2(*, xs, mu, alpha, beta, c, **_):
    v0 = c*mu/(2*(1+c*mu)*(1+beta+c*alpha))
    return np.heaviside(-xs, .5)*v0*np.exp(xs) + np.heaviside(xs, .5)*v0*np.exp(-xs/(c*alpha))
